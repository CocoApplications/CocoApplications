{"version":3,"sources":["mcmc.js"],"names":[],"mappings":"AAAA;;;;;;;;IAGM,S;;;;AAGF,uBAAY,YAAZ,EAA0B,OAA1B,EAAmC,OAAnC,EAA4C;AAAA;;AACxC,aAAK,YAAL,GAAoB,YAApB;AACA,aAAK,SAAL,GAAiB,EAAjB;AACA,aAAK,SAAL,CAAe,IAAf,CAAoB,CAAC,OAAD,EAAU,OAAV,CAApB;AACA,aAAK,CAAL,GAAS,CAAT;AACA,aAAK,MAAL,GAAc,IAAI,eAAJ,CAAoB,EAApB,CAAd;AACH;;;;+BAEM,C,EAAE;AAAC,mBAAO,KAAK,YAAL,CAAkB,MAAlB,CAAyB,CAAzB,CAAP;AAAoC;;;6BACzC,C,EAAE;AAAC,mBAAO,KAAK,YAAL,CAAkB,QAAlB,CAA2B,CAA3B,CAAP;AAAsC;;;wCAE9B,C,EAAE;AACd,iBAAK,CAAL,GAAS,CAAT;AACH;;;oCAEW,Q,EAAU;AAClB,mBAAO,CAAC,SAAS,CAAT,CAAD,EAAc,SAAS,CAAT,CAAd,EAA2B,KAAK,MAAL,CAAY,QAAZ,CAA3B,CAAP;AACH;;;;;;sCAGuB;AAAA,gBAAZ,MAAY,uEAAL,GAAK;;AACpB,gBAAI,eAAe,KAAK,SAAL,CAAe,KAAK,SAAL,CAAe,MAAf,GAAwB,CAAvC,CAAnB;AACA,gBAAI,eAAe,CACf,aAAa,CAAb,IAAkB,KAAK,MAAL,CAAY,aAAZ,CAA0B,CAA1B,EAA6B,CAA7B,IAAkC,MADrC,EAEf,aAAa,CAAb,IAAkB,KAAK,MAAL,CAAY,aAAZ,CAA0B,CAA1B,EAA6B,CAA7B,IAAkC,MAFrC,CAAnB;AAIA,gBAAI,aAAa,KAAK,MAAL,CAAY,YAAZ,CAAjB;AACA,gBAAI,aAAa,KAAK,MAAL,CAAY,YAAZ,CAAjB;AACA,gBAAI,SAAS,KAAK,MAAL,CAAY,MAAZ,KAAuB,KAAK,GAAL,CAAS,CAAC,aAAa,UAAd,IAA4B,KAAK,CAA1C,CAApC;AACA,gBAAI,eAAJ;;AAEA,gBAAG,MAAH,EAAU;AACN,yBAAS,MAAM,YAAN,CAAT;AACH,aAFD,MAEO;AACH,yBAAS,MAAM,YAAN,CAAT;AACH;AACD,iBAAK,SAAL,CAAe,IAAf,CAAoB,MAApB;;;AAGA,mBAAO,CAAC,KAAK,WAAL,CAAiB,MAAjB,CAAD,EAA2B,KAAK,WAAL,CAAiB,YAAjB,CAA3B,EAA2D,MAA3D,CAAP;AACH;;;sCAEa,Q,EAAU,Q,EAAU,O,EAAsC;AAAA,gBAA7B,eAA6B,uEAAb,EAAa;AAAA,gBAAT,IAAS,uEAAJ,EAAI;;AACpE,uBAAW,YAAY,QAAZ,CAAqB,QAArB,EAA+B,KAAK,IAAL,CAAU,eAAV,CAA/B,CAAX;AACA,uBAAW,YAAY,eAAZ,CAA4B,QAA5B,EAAsC,QAAtC,EAAgD,EAAhD,EAAoD,UAAU,EAAV,GAAe,IAAnE,CAAX;AACA,gBAAI,WAAW,KAAK,IAAL,CAAU,QAAV,CAAf;AACA,uBAAW,YAAY,eAAZ,CAA4B,QAA5B,EAAsC,QAAtC,EAAgD,EAAhD,EAAoD,CAAE,OAAtD,CAAX;AACA,uBAAW,YAAY,eAAZ,CAA4B,QAA5B,EAAsC,QAAtC,EAAgD,EAAhD,EAAoD,UAAU,EAAV,GAAe,IAAnE,CAAX;AACA,uBAAW,YAAY,QAAZ,CAAqB,QAArB,EAA+B,KAAK,IAAL,CAAU,eAAV,CAA/B,CAAX;AACA,mBAAO,CAAC,QAAD,EAAW,QAAX,CAAP;AACH;;;;;;;;;uCAM0F;AAAA;;AAAA,2FAAJ,EAAI;gBAAA,4BAA7E,eAA6E;gBAA7E,eAA6E,wCAA7D,KAA6D;gBAAA,sBAAtD,SAAsD;gBAAtD,SAAsD,kCAA5C,MAA4C;gBAAA,oBAApC,OAAoC;gBAApC,OAAoC,gCAA5B,EAA4B;gBAAA,4BAAxB,eAAwB;gBAAxB,eAAwB,wCAAR,EAAQ;;AACvF,gBAAI,WAAY,KAAK,GAAL,CAAS,CAAT,EAAY,KAAK,MAAL,CAAY,aAAZ,CAA0B,OAA1B,EAAmC,KAAK,IAAL,CAAU,OAAV,CAAnC,CAAZ,CAAhB;;AADuF,4CAElE,KAAK,SAAL,CAAe,KAAK,SAAL,CAAe,MAAf,GAAwB,CAAvC,CAFkE;gBAElF,KAFkF;gBAE3E,KAF2E;;AAGvF,gBAAI,WAAW,CAAC,KAAD,EAAQ,KAAR,CAAf;AACA,gBAAI,iBAAiB,QAArB;AACA,gBAAI,WAAW,CAAC,KAAK,MAAL,CAAY,aAAZ,CAA0B,CAA1B,EAA6B,CAA7B,IAAkC,KAAK,IAAL,CAAU,KAAK,CAAf,CAAnC,EACC,KAAK,MAAL,CAAY,aAAZ,CAA0B,CAA1B,EAA6B,CAA7B,IAAkC,KAAK,IAAL,CAAU,KAAK,CAAf,CADnC,CAAf;AAEA,gBAAI,aAAa,KAAK,MAAL,CAAY,QAAZ,IAAwB,YAAY,YAAZ,CAAyB,QAAzB,IAAqC,EAA9E;;AAEA,gBAAI,aAAa,CAAC,CAAC,QAAD,EAAW,QAAX,CAAD,CAAjB;;AAEA,iBAAI,IAAI,YAAU,CAAlB,EAAqB,YAAY,QAAjC,EAA2C,WAA3C,EAAwD;;AAEpD,oBAAI,kBAAkB,KAAK,GAAL,CAAS,eAAT,EAA0B,CAAC,KAAK,IAAL,CAAU,IAAI,SAAJ,GAAgB,CAAhB,GAAoB,QAA9B,CAA3B,CAAtB;;;AAFoD,qCAI7B,KAAK,aAAL,CAAmB,QAAnB,EAA6B,QAA7B,EAAuC,SAAvC,EAAkD,eAAlD,CAJ6B;;AAAA;;AAInD,wBAJmD;AAIzC,wBAJyC;;AAKpD,2BAAW,IAAX,CAAgB,CAAC,QAAD,EAAW,QAAX,CAAhB;AACH;;AAED,gBAAI,aAAa,KAAK,MAAL,CAAY,QAAZ,IAAwB,YAAY,YAAZ,CAAyB,QAAzB,IAAqC,EAA9E;;AAEA,gBAAI,SAAS,KAAK,MAAL,CAAY,MAAZ,KAAuB,KAAK,GAAL,CAAS,CAAC,aAAa,UAAd,IAA4B,KAAK,CAA1C,CAApC;AACA,gBAAG,eAAH,EAAoB;AAChB,yBAAS,KAAT;AACH;AACD,gBAAI,eAAJ;AACA,gBAAG,MAAH,EAAU;AACN,yBAAS,cAAT;AACH,aAFD,MAEO;AACH,yBAAS,QAAT;AACH;AACD,iBAAK,SAAL,CAAe,IAAf,CAAoB,MAApB;AACA,gBAAI,gBAAgB,WAAW,GAAX,CAAe,UAAC,CAAD;AAAA,uBAAO,MAAK,WAAL,CAAiB,EAAE,CAAF,CAAjB,CAAP;AAAA,aAAf,CAApB;;;AAGA,mBAAO,CAAC,KAAK,WAAL,CAAiB,MAAjB,CAAD,EAA2B,KAAK,WAAL,CAAiB,QAAjB,CAA3B,EAAuD,MAAvD,EAA+D,aAA/D,CAAP;AACH;;;4CAEkB;AAAA;;AACf,mBAAO,KAAK,SAAL,CAAe,GAAf,CAAmB,UAAC,CAAD;AAAA,uBAAO,OAAK,WAAL,CAAiB,CAAjB,CAAP;AAAA,aAAnB,CAAP;AACH","file":"mcmc-compiled.js","sourcesContent":["\"use strict\";\n\n\nclass MCSampler {\n    // both energy and position accept one argument - vector.\n    // in the case of demonstration vector can have only one or two variables.\n    constructor(distribution, x_start, y_start) {\n        this.distribution = distribution;\n        this.positions = [];\n        this.positions.push([x_start, y_start]);\n        this.T = 1;\n        this.random = new RandomGenerator(42);\n    }\n\n    energy(x){return this.distribution.energy(x);}\n    grad(x){return this.distribution.gradient(x);}\n\n    set_temperature(T){\n        this.T = T;\n    }\n\n    to_3d_point(position) {\n        return [position[0], position[1], this.energy(position)];\n    }\n\n    // metropolis - hastings\n    generate_mh(spread=0.1) {\n        let position_old = this.positions[this.positions.length - 1];\n        let position_new = [\n            position_old[0] + this.random.random_normal(0, 1) * spread,\n            position_old[1] + this.random.random_normal(0, 1) * spread\n        ];\n        let energy_old = this.energy(position_old);\n        let energy_new = this.energy(position_new);\n        let reject = this.random.random() > Math.exp((energy_old - energy_new) / this.T);\n        let result;\n\n        if(reject){\n            result = clone(position_old);\n        } else {\n            result = clone(position_new);\n        }\n        this.positions.push(result);\n        \n        // return final position, candidate, and reject solution\n        return [this.to_3d_point(result), this.to_3d_point(position_new), reject];\n    }\n\n    leapfrog_step(position, momentum, epsilon, iteration_alpha=1., mass=1.) {\n        momentum = VectorUtils.multiply(momentum, Math.sqrt(iteration_alpha));\n        position = VectorUtils.add_with_coeffs(position, momentum, 1., epsilon / 2. / mass);\n        let gradient = this.grad(position);\n        momentum = VectorUtils.add_with_coeffs(momentum, gradient, 1., - epsilon);\n        position = VectorUtils.add_with_coeffs(position, momentum, 1., epsilon / 2. / mass);\n        momentum = VectorUtils.multiply(momentum, Math.sqrt(iteration_alpha));\n        return [position, momentum];\n    }\n\n    // hamiltonian monte-carlo\n    // step_size = epsilon in Neal's paper\n    // n_steps = L in Neal's paper\n    // tempering_alpha - alpha from Neal's paper\n    generate_hmc({suppress_reject=false, step_size=0.0513, n_steps=60, tempering_alpha=1.}={}) {\n        let n_steps_ =  Math.max(1, this.random.random_normal(n_steps, Math.sqrt(n_steps)));\n        let [x_old, y_old] = this.positions[this.positions.length - 1];\n        let position = [x_old, y_old];\n        let start_position = position;\n        let momentum = [this.random.random_normal(0, 1) * Math.sqrt(this.T),\n                        this.random.random_normal(0, 1) * Math.sqrt(this.T)];\n        let energy_old = this.energy(position) + VectorUtils.norm_squared(momentum) / 2.;\n\n        let trajectory = [[position, momentum]];\n\n        for(let iteration=0; iteration < n_steps_; iteration++) {\n            // alpha in the first half of trajectory, 1 / alpha in second, 1 in the middle\n            let iteration_alpha = Math.pow(tempering_alpha, -Math.sign(2 * iteration + 1 - n_steps_) );\n            // console.log('alpha', iteration, iteration_alpha);\n            [position, momentum] = this.leapfrog_step(position, momentum, step_size, iteration_alpha);\n            trajectory.push([position, momentum]);\n        }\n\n        let energy_new = this.energy(position) + VectorUtils.norm_squared(momentum) / 2.;\n\n        let reject = this.random.random() > Math.exp((energy_old - energy_new) / this.T);\n        if(suppress_reject) {\n            reject = false;\n        }\n        let result;\n        if(reject){\n            result = start_position;\n        } else {\n            result = position;\n        }\n        this.positions.push(result);\n        let trajectory_3d = trajectory.map((x) => this.to_3d_point(x[0]));\n\n        // return final position, candidate, and reject solution\n        return [this.to_3d_point(result), this.to_3d_point(position), reject, trajectory_3d];\n    }\n\n    get_3d_trajectory(){\n        return this.positions.map((x) => this.to_3d_point(x));\n    }\n}\n\n"]}